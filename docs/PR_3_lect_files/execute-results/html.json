{
  "hash": "5d7b282bcb98577a25b996fa3aba3be3",
  "result": {
    "markdown": "---\ntitle: \"Práctica 3 <br> Importación y manipulación de datos.\"\nauthor: \"Jesús Esteban Hernández\"\ndate: \"2/12/2022\"\noutput:\n  html_document: \n    theme: cosmo\n    code_folding: show\n    toc: yes\n    number_sections: yes\n    toc_depth: 5\n    toc_float: yes\n    \n  # html_notebook:\n  #   # theme: readable\n  #   code_folding: show\n  #   toc: true\n  #   toc_float: \n  #     collapsed: false\n  #   toc_depth: 5\n  #   # toc-title: Table of contents #toc-title no me funciona.\n  #   number_sections: yes\n  # Opciones aquí https://garrettgman.github.io/rmarkdown/html_document_format\n  pdf_document:\n    toc: yes\n    toc_depth: 5\n    latex_engine: lualatex\nlan: es-ES\neditor_options:\nbibliography: MasterUE.bib\nbiblio-style: apalike\nlink-citations: true\n#csl: biomed-central.csl\nchunk_output_type: inline\n---\n\n::: {.cell}\n<style type=\"text/css\">\n<style type=\"text/css\">\n  \n  .TOC {\n    left:0;\n    width:200px;\n    margin-left: 0px;\n    right: 2px;\n    margin: 2px 20px 20px 0px;\n    color: red;\n    font-size: 2px;\n  }\n\n  .main-container {\n  \n  width:1800px !important;\n  margin-left: 10px;\n  margin-right: 10px;\n  \n}\n\nbody {\n  font-size: 14pt;\n  font-family: Helvetica;\n  <!-- color: red; -->\n  <!-- background-color: olive; -->\n  \n}\n\nh1 {\n  font-size: 34px;\n}\n\nh2 {\n  font-size: 20px;\n  color: red;\n  text-indent:10px;\n\n}\n\nh3 {\n  font-size: 20px;\n  color: blue;\n  text-indent:15px;\n\n}\n\n\nh4 {\n  font-size: 20px;\n  color: green;\n  text-indent:20px;\n\n}\n\ntocify-header {\n    text-indent: initial;\n}\n\n.gt_table {\n  margin-left: 10px !important;\n  margin-right: 10px !important;\n  width: auto !important;\n  \n}\n\n\n</style>\n\n</style>\n:::\n\n\n\n\n\nRecuerda siempre cómo *\"piensa\"* R.\n\n![Cómo piensa R](pics/como_piensa_R.png){width=\"75%\"}\n\n# Importación y manipulación de datos en R.\n\nEn la sección anterior hemos visto lo fundamental sobre estructuras y hemos comentado las características de una estructura clave en el manejo de datos en R: **dataframe**.\nEn esta práctica vamos a ver cómo importar datos y como transformarlos usando *base R*.\nAl final comentaremos como hacer los mismo con *modern R*.\n\n## Importación de datos.\n\nComo comentábamos, la importación consiste en construir un objeto, generalmente de tipo dataframe a partir de un archivo externo.\n\nPara hacerlo necesitamos que el archivo externo tenga una estructura matricial (.xlsx) o que pueda convertirse en matricial (.csv) porque incluya caracteres de separación que le indiquen al programa que lo importa, en nuestro caso R, cuando cambiamos de columna o de fila.\n\nSe han incorporado muchas funciones a R que realizan la importación de forma casi automática, pero entender sus fundamentos puede ayudar a entender y resolver problemas de importación.\n\nNos vamos a centrar en dos estructuras desde las que con frecuencia vamos a importar datos.\n\n### Importación desde archivo .csv (Comma Separated Values).\n\nUna de las más sencillas si el archivo .csv está bien construido.\nUn archivo .csv no es más que un archivo de texto en el que el carácter coma (\",\") separa campos (variables) y el salgo de línea separa registros (individuos/elementos).\n\n>\nEn realidad cualquier estructura de texto que utilice un separador de campos (variables) y de registros (líneas) es susceptible de ser importada. R tiene una función muy básica para hacerlo (*read.table*), a la que le indicamos el carácter separador de campos (\",\", \";\",\"/\",\"/tab\"...), si el archivo contiene encabezado (header), una primera línea en la que se almacenan los nombres de las variables, o el carácter que utiliza como separador decimal. En realidad tiene muchos otros argumentos, pero no son necesarios para realizar importaciones sencillas. Por ejemplo, la función que utilizaremos a continuación en realida es una adaptación de esta en la que por defecto se establece que el separador de campos es la coma (\",\"), entre otros argumentos.\n\n\n\n\n\nComo comentábamos, el .csv es un formato estándar, que pesa poco y hay funciones diseñadas para leer este tipo de archivos.\n\nEntre los archivos de trabajo, hemos incluido un archivo llamado myiam2.\nEs un archivo con extensión .csv que contiene una base de datos de pacientes que habían padecido un infarto.\n\nVamos a crear un dataframe importándola y como sabemos que se trata de un csv, vamos a utilizar al función *read.csv* del paquete *utils*.\nEn este caso no hace falta cargarla porque este paquete se carga al iniciar R.\n\nRecuerde que hay que indicar el dirección en la que está el archivo.\nEn este ejemplo, que explicaremos en clase, vamos a utilizar direccionamiento relativo al directorio en el que está el archivo desde mi directorio de trabajo.\n\n> Importante. \nLa dirección de las barras de dirección (las que separan directorios y subdirectorios) en R vienen del mundo UNIX (un sistema operativo diferente a Windows), por eso las barras se inclinan hacia el lado contrario. En clase veremos alguna función que facilita copiar y pegar las direcciones desde Windows adaptándolas al lenguaje de R. Se puede hacer invirtiendo las barras que vienen de Windows, o duplicándolas manteniendo la dirección.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niam<-read.csv('data/myiam2.csv') # Utilizando relative path.\n```\n:::\n\n\nLa salidas de las funciones read suele ser un dataframe, y por ello podemos asignarlo directamente a un objeto, en el ejemplo el objeto (dataframe) llamado iam.\n\nPedimos las primeras filas del dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(iam)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Id      Age Sex Height Weight Smoke ami\n1  1 65.24100   1   1.62  74.56     0   0\n2  2 62.45461   0   1.56  60.89     0   0\n3  3 64.68328   0   1.69  74.20     0   0\n4  4 65.36045   0   1.34  43.92     0   0\n5  5 70.71094   0   1.81  80.86     1   0\n6  6 65.42030   0   1.78  80.56     0   0\n```\n:::\n:::\n\n\nTambién podemos pedir la estructura que nos da mucha información sobre el contenido del dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(iam)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t100 obs. of  7 variables:\n $ Id    : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Age   : num  65.2 62.5 64.7 65.4 70.7 ...\n $ Sex   : int  1 0 0 0 0 0 1 0 0 0 ...\n $ Height: num  1.62 1.56 1.69 1.34 1.81 1.78 1.79 1.44 1.56 1.87 ...\n $ Weight: num  74.6 60.9 74.2 43.9 80.9 ...\n $ Smoke : int  0 0 0 0 1 0 0 1 0 0 ...\n $ ami   : int  0 0 0 0 0 0 0 1 0 0 ...\n```\n:::\n:::\n\n\nEn realidad esta estructura también está visible si desplegamos el dataframe en la pestaña Environment, ventana data del panel superior derecho.\n\n![vent_data](pics/iam_en_vent_data.png)\n\nEsta función nos informa del contenido del objeto.\nAl tratarse de un dataframe, nos muestra las variables, el tipo de dato que almacena cada una (en este ejemplo solo hay numérico y enteros) y las primeras observaciones.\nEs el primer punto de control en el que podemos observar si la importación ha ido como esperábamos.\n\n### Importación desde archivo .xlsx (Excel).\n\nEl concepto de importación es el mismo independientemente de la fuente de los datos, pero las funciones a utilizar cambian para responder a las especificidades del tipo de archivo.\n\nR no cuenta con función propia para leer un archivo xlsx, pero otras librerías lo han incorporado.\n\nEl siguiente ejemplo crea el mismo dataframe, pero en esta ocasión desde un archivo .xlsx.\nUtilizaremos la librería *readxl* (si no la tiene instalada, hágalo antes de ejecutar el siguiente código).\n\nPodríamos cargar la librería con library(readxl), pero vamos a aprovechar para mostrar cómo podemos llamar a una biblioteca (library) sin cargarla en memoria.\nLa clave es anteceder el nombre de la función con el nombre de la biblioteca seguido de *\"::\"*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niam2<-readxl::read_xlsx('data/myiam3.xlsx')\n```\n:::\n\n\nPedimos la estructura\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(iam2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [100 × 8] (S3: tbl_df/tbl/data.frame)\n $ Id    : num [1:100] 1 2 3 4 5 6 7 8 9 10 ...\n $ Sex   : chr [1:100] \"1\" \"0\" \"0\" \"0\" ...\n $ Height: num [1:100] 1.62 1.56 1.69 1.34 1.81 1.78 1.79 1.44 1.56 1.87 ...\n $ Weight: num [1:100] 74.6 60.9 74.2 43.9 80.9 ...\n $ Smoke : chr [1:100] \"0\" \"0\" \"0\" \"0\" ...\n $ Ami   : chr [1:100] \"0\" \"0\" \"0\" \"0\" ...\n $ fecing: POSIXct[1:100], format: \"2015-03-18 21:05:08\" \"2015-08-07 04:23:18\" ...\n $ fnac  : POSIXct[1:100], format: \"1949-12-20 14:28:29\" \"1953-02-21 15:15:58\" ...\n```\n:::\n:::\n\n\nEn realidad vemos que la nueva base de datos no es exactamente la anterior.\nLas variables Sex, Smoke y Ami son de tipo carácter.\nAdemás no incluye la edad, pero sí la fecha de ingreso y la fecha de nacimiento.\n\nNo es infrecuente que nuestros datos procedan de otro paquete estadístico o tipo de fichero.\nLa biblioteca *foreign* incluye funciones para acometer esta tarea desde varias fuentes, incluyendo los tres software de análisis más habituales en nuestro contexto (SAS,SPSS,Stata).\n\n+---------------+----------------+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n|    \\          |    \\           |    \\           |    \\                                                                                                                                                                                         |\n| **Programa**\\ | **Paquete**    | **Función**    | **Argumentos y opciones más   frecuentes/predefinidas**                                                                                                                                      |\n|    \\          |                |                |                                                                                                                                                                                              |\n|               |                |                |                                                                                                                                                                                              |\n+:==============+:===============+:===============+:=============================================================================================================================================================================================+\n|    \\          |    \\           |    \\           |    \\                                                                                                                                                                                         |\n| SPSS          | foreign        | read.spss()    | read.spss(file,   use.value.labels = TRUE,   to.data.frame = FALSE, max.value.labels = Inf, trim.factor.names = FALSE,   trim_values = TRUE, reencode = NA, use.missings = to.data.frame)    |\n+---------------+----------------+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n|    \\          |    \\           |    \\           |    \\                                                                                                                                                                                         |\n| Stata         | foreign        | read.dta()     | read.dta(file, convert.dates = TRUE,   convert.factors = TRUE, missing.type = FALSE, convert.underscore = FALSE,   warn.missing.labels = TRUE)                                               |\n+---------------+----------------+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n|    \\          |    \\           |    \\           |    \\                                                                                                                                                                                         |\n| SAS           | haven          | read_sas()     | read_sas(data_file,   catalog_file = NULL, encoding = NULL, cols_only = NULL)                                                                                                                |\n+---------------+----------------+----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nTambién existen paquetes más específicos para importar desde alguno de ellos, como *readstata13*, que permiten opciones adicionales.\n\n## Manipulación de datos.\n\nAntes de poder modificar variables existentes o crear algunas nuevas, necesitamos conocer algunas funciones y operadores básicos incluidos en la instalación básica de r.\n\n### Operadores.\n\n| Operadores comparativos | Símbolo/instrucción |\n|:-----------------------:|:-------------------:|\n|        igualdad         |         ==          |\n|       desigualdad       |         !=          |\n|          menor          |         \\<          |\n|       menor igual       |         \\<=         |\n|          mayor          |         \\>          |\n|      maryor igual       |         \\>=         |\n\n| Operadores lógicos | Símbolo/instrucción |\n|:------------------:|:-------------------:|\n|     AND lógica     |          &          |\n|     OR lógica      |         \\|          |\n|  negación lógica   |          !          |\n|     Identidad      |         &&          |\n\n### Funciones básicas.\n\n|      **Operador/Función**      | **Símbolo/instrucción** |\n|:------------------------------:|:-----------------------:|\n|              suma              |           \\+            |\n|             resta              |           \\-            |\n|         multiplicación         |           \\*            |\n|            división            |            /            |\n|             módulo             | %% (resto de división)  |\n|        división entera         |           %/%           |\n|         raíz cuadrada          |          sqrt           |\n|   logaritmo natural (base e)   |           log           |\n| logaritmos genérico (base-\\>b) |  logb (ex. log10(45))   |\n|      número e elevado a x      |         exp(x)          |\n|             máximo             |           max           |\n|             mínimo             |           min           |\n|             rango              |          range          |\n|            longitud            |         length          |\n|           sumatorio            |           sum           |\n|          productorio           |          prod           |\n|             media              |          mean           |\n|            mediana             |         median          |\n|         desv. estándar         |           sd            |\n|            varianza            |           var           |\n\n### Manipulaciones más frecuentes.\n\nSeguiremos utilizando el dataframe generado anteriormente llamado *iam*.\n\n#### Recodificar en base a puntos de corte. (Convertir numérica en factor)\n\nLa función cut es muy útila para generar una variable categórica a partir de una cuantitativa discreta o continua.\nSolo necesitas que le entregemos el vector a cortar y los puntos de corte.\nVeamos un par de ejemplos.\n\nConstruiremos grupos de edad e intervalos de 10 años.\nEl máximo de esta variable es 70.71 y el mínimo es 59.5, así pues nos hacen falta puntos de corte entre ambos valores con amplitud de 10 años.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niam$age5<-cut(iam$Age,seq(55,75,10),include.lowest = T,right = T) # la función seq nos facilita la tarea de construir el vector de puntos de corte.\n```\n:::\n\n\nLa propia función genera un factor (ya hablaremos de este tipo de objetos que servirán para almacenar variables categóricas )\n\nPodemos construir una tabla para comprobar la distribución de la nueva variable categórica.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(iam$age5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n[55,65] (65,75] \n     47      53 \n```\n:::\n:::\n\n\nComo se puede observar, la propia función genera las etiquetas de los intervalos en función de los puntos de corte que le hemos dado.\nA tener en cuenta:\n\n```         \n* La función *cut* tiene argumentos para poder construir los intervalos cerrando el intervalo por su límite derecho (argumento right=T) .\n* la función *cut* genera un objeto de tipo vector y de clase factor, por lo que sus etiquetas de nivel se pueden modificar (lo veremos al hablar de factores).\n* la función *cut* puede cerrar el intervalo inferior (argumento include.lowest=T)\n```\n\n#### Construir variables operando otras.\n\nEn el dataframe *iam* se incluyen las variables peso y altura.\nVamos a construir el Índice de Masa Corporal.\n\n$$IMC=\\frac{Peso (kg)}{Altura(m)^2}$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\niam$bmi<-iam$Weight/iam$Height^2\n```\n:::\n\n\nComo se puede observar, para incluirla en el dataframe, hemos de indicarlo utilizando el nombre del mismo seguido de \\$ y el nombre que queremos dar a la nueva variable, en este caso *bmi*.\n\n#### Recodificación.\n\nPosiblemente una de las tareas más frecuentes, si no la más frecuente, manipulando datos es la recodificación, construir una variable categórica agrupando categorías de otra.\n\nPara entender esta tarea en R, es útil entender la clase factor, la clase en la que vamos a almacenar las variables categóricas.\n\n#### Factores ¿Qué es un factor en R?\n\nLos factores son posiblemente uno de los elementos básicos en R que más cuesta entender.\nEn mi opinión tiene que ver con la confusión entre el concepto de nivel (level) y la etiqueta (label) que se le asigna a cada uno de los niveles.\n\nPara explicar cómo funciona, vamos a crear un ejemplo sencillo para ver cómo operan estas dos características.\n\nAunque parezca extraño, vamos a partir de un vector de tipo *integer* para posteriormente convertirlo en uno de tipo factor al que añadiremos las etiquetas.\n\n-   Construcción de un vector numérico.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx<-rep(0:1,25)\n```\n:::\n\n\n-   Conversión del vector en un factor, sin decirle nada más.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex<-factor(x)\n```\n:::\n\n\n-   Al utilizar la función factor, R lee el vector que recibe y, si no le decimos otra cosa, identifica los valores diferentes y los ordena en orden alfanumérico.\n\n-   Acto seguido va asignado el nivel correspondiente a cada valor diferente, y utiliza el valor original para construir una etiqueta.\n\n-   Lo que obtenemos es un vector de tipo factor que tiene niveles que van del 1 al número de valores diferentes que trajese la variable (el vector) original.\n    Pero estos niveles están ocultos detrás de las etiquetas que se les asignan.\n\n-   Lo importante es el nivel, pero su relación con la etiqueta asignada nos va a permitir recodificar variables utilizando las etiquetas que se les asignan.\n\nVeamos un ejemplo.\n\nEl vector sex, creado con el código anterior, tiene dos niveles, 1 y 2, pero las etiquetas que fueron asignadas como indiqué, son \"0\" y \"1\", valores originales del vector.\nAl no decirle lo contrario, usó el orden alfanumérico, por eso el 0 se asigna al primer nivel y el 1 al segundo nivel.\n\nSi queremos ver los auténticos niveles que contiens podemos forzar una conversión de tipo de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\n[39] 0 1 0 1 0 1 0 1 0 1 0 1\nLevels: 0 1\n```\n:::\n\n```{.r .cell-code}\nas.numeric(sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n[39] 1 2 1 2 1 2 1 2 1 2 1 2\n```\n:::\n:::\n\n\nObserve como el primer vector muestra las etiquetas, mientras que el segundo muestra los niveles.\n\nEn realidad podríamos haber impuesto nuestras etiquetas a dichos niveles en la propia creación del factor, pero para eso debemos entender que si no le decimos lo contrario, la identificación del orden de asignación sigue dependiendo del orden alfanumérico.\n\nPara indicarle las etiquetas, basta con meter un vector con las etiquetas en el argumento *labels.*\n\nEn este ejemplo asumimos que el 0 es el valor con el que en la base de datos original se codificó Hombre y 1 el valor con el que se codificó Mujer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex2<-factor(x,labels = c('Hombre','Mujer'))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsex2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[11] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[21] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[31] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[41] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \nLevels: Hombre Mujer\n```\n:::\n\n```{.r .cell-code}\nas.numeric(sex2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n[39] 1 2 1 2 1 2 1 2 1 2 1 2\n```\n:::\n:::\n\n\nComo se puede observar, los niveles (1 y 2) siguen siendo los mismos, pero las etiquetas han cambiado.\n\nTambién se obseva como cuando pedimos un vector de clase factor, debajo aparecen los niveles (Levels: Hombre Mujer) en el orden en que se asignan a los niveles subyacentes (1 y 2).\n\nImaginemos que por alguna razón hubiésemos querido que el primer nivel se asignase a Mujer aunque el código que se asignó en la base de datos original fue el superior (1).\nPodemos obligar a que la función lea los niveles como nosotros deseemos usando el argumento levels.\n\n>\nLa posición que asignemos a los niveles tendrá importancia en la construcción de los modelos, puesto que, aunque se puede cambiar, la comparación que se establece por defecto es contra el nivel más bajo, que funcionará como nivel de referencia. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex3<-factor(x,levels=c(\"1\",\"0\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsex3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\n[39] 0 1 0 1 0 1 0 1 0 1 0 1\nLevels: 1 0\n```\n:::\n\n```{.r .cell-code}\nas.numeric(sex3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1\n[39] 2 1 2 1 2 1 2 1 2 1 2 1\n```\n:::\n:::\n\n\nAhora los ceros (hombres), han sido asignados al nivel 2 y los unos (mujeres al nivel 1).\nPor supuesto podríamos haber colocado nuestras etiquetas en la propia creación, pero debemos tener en cuenta que hemos impuesto un nuevo orden a los niveles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex4<-factor(x,levels=c(\"1\",\"0\"),labels=c('Women','Men'))\nsex4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[13] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[25] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[37] Men   Women Men   Women Men   Women Men   Women Men   Women Men   Women\n[49] Men   Women\nLevels: Women Men\n```\n:::\n\n```{.r .cell-code}\nas.numeric(sex4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1\n[39] 2 1 2 1 2 1 2 1 2 1 2 1\n```\n:::\n:::\n\n\nLa informacion contenida en el vector no ha cambiado (donde había un Hombre ahora también, aunque con la etiqueta Men), pero el nivel asignado sí lo ha hecho.\n\n¿Cómo saber los niveles que tiene un factor?\n\nMediante la función levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(sex4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Women\" \"Men\"  \n```\n:::\n:::\n\n\nComo se puede observar, esta función devuelve un vector.\nPues bien, podemos modificar dicho vector para cambiar las etiquetas del factor, siempre que tengamos claro el orden de los niveles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(sex4)<-c('Mujer','Hombre')\nsex4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[11] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[21] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[31] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \n[41] Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer  Hombre Mujer \nLevels: Mujer Hombre\n```\n:::\n:::\n\n\nEs más, esta función nos permite recodificar los niveles de manera fácil como veremos posteriormente.\n\nPodemos crear factores a partir de cualquier tipo de vector.\nDe hecho, con frecuencia este vector es de tipo *character*, es decir que trae \"puesta\" la etiqueta.\n\nSí así fuera, basta con utilizar la función factor par construir el vector.\nVeamos un ejemplo.\n\nConstruiremos un vector de tipo *character*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnse<-c(rep('NSE1',10),rep('NSE2',4),rep('NSE3',12),rep('NSE4',5))\n# hay formas más elegantes de construir este vector, pero hacen falta funciones que aún no hemos visto.\n```\n:::\n\n\nComo se puede ver, las palabras contenidas en el vector están entre comillas, lo que señala que se trata de cadenas de caracteres.\n\nConversión en factor asumiendo el orden alfanumérico de los valores diferentes dentro del vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnse_f<-factor(nse)\nnse_f\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 NSE2 NSE3 NSE4\n```\n:::\n:::\n\n\nComo se puede observar, la conersión en factor hace que tenga niveles (Levels: NSE1 NSE2 NSE3 NSE4) cuyo orden ha sido establecido por el orden alfanumérico de las cadenas de caracteres que contenía el vector.\n\nPara que se entienda cómo actúa la conversión, vamos a construir un vector parecido pero en el que una de las cadenas no sigue el patrón NSE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnse2<-c(rep('NSE1',10),rep('SNE2',4),rep('NSE3',12),rep('NSE4',5))\nnse2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\" \"NSE1\"\n[11] \"SNE2\" \"SNE2\" \"SNE2\" \"SNE2\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\"\n[21] \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE3\" \"NSE4\" \"NSE4\" \"NSE4\" \"NSE4\"\n[31] \"NSE4\"\n```\n:::\n:::\n\n\nEste vector es parecido al nse, solo cambia la cadena de 4 elementos, que ahora es SNE2 en vez de NSE2.\n\nAl transformarlo en factor:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnse2_f<-factor(nse2)\nnse2_f\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 SNE2 SNE2 SNE2 SNE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 NSE3 NSE4 SNE2\n```\n:::\n:::\n\n\n...podemos ver como SNE2 se ha colocado en el cuarto nivel, que es el que le corresponde al ordenar alfabéticamente los niveles diferentes (valores diferentes en el contenido) detectados por la función.\n\nEsto no afecta a la información en sí misma, pues la etiqueta signada al nivel 4 estará allá donde el vector de caracteres incluyera \"SNE2\".\n\nEn realidad podríamos haberlo evitado indicando la colocación de los niveles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnse2_f2<-factor(nse2,levels = c('NSE1','SNE2','NSE3','NSE4'))\nnse2_f2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 SNE2 SNE2 SNE2 SNE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 SNE2 NSE3 NSE4\n```\n:::\n:::\n\n\n#### Recodificación.\n\nLa recodificación es fácil cuando se hace sobre el factor, porque basta con reasignar las etiquetas a los niveles.\nEsta relación entre *levels* y *labels* es la que, en mi opinión, genera más confusión a la hora de entender los factores.\n\nVamos a recodificar el vector nse_f (el primer factor que generamos) agrupando los niveles 2 y 3.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Crearemos una copia para no perder el anterior y poder comparar los efectos.\nnse_f_rec<-nse_f \nnse_f_rec #Vemos que es el mismo vector.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 NSE2 NSE3 NSE4\n```\n:::\n\n```{.r .cell-code}\nlevels(nse_f_rec) #Preguntamos por los niveles.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"NSE1\" \"NSE2\" \"NSE3\" \"NSE4\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(nse_f_rec) # visualizamos los niveles subyacentes.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 4 4 4 4 4\n```\n:::\n:::\n\n\nCambiamos los niveles actuando sobre las etiquetas de nivel.\nConfunde, porque parece que solo estamos cambiando la etiqueta y que por debajo permanecerán los cuatro niveles, pero...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(nse_f_rec)<-c('NSE1','NSE2_3','NSE2_3','NSE4')  \nlevels(nse_f_rec) # No solo son tres etiquetas.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"NSE1\"   \"NSE2_3\" \"NSE4\"  \n```\n:::\n\n```{.r .cell-code}\nas.numeric(nse_f_rec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3\n```\n:::\n:::\n\n\nPodemos ver cómo ha ido la recodificación construyendo una tabla de contingencia con los dos vectores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(nse_f_rec,nse_f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         nse_f\nnse_f_rec NSE1 NSE2 NSE3 NSE4\n   NSE1     10    0    0    0\n   NSE2_3    0    4   12    0\n   NSE4      0    0    0    5\n```\n:::\n:::\n\n\n>\nEs importante tener en cuenta que esta acción ya no puede ser deshecha; no podemos volver al vector que los tenía separados si no contamos con el original o versiones previas del que hemos destruido al generar el nuevo.\n\n\nPor un método parecido podemos reordenar los niveles para que el nivel de referencia sea el que deseemos.\n\nEn el siguiente ejemplo vamos a conseguir que sea el NSE4 el nivel de referencia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnse_f_rec<-relevel(nse_f_rec,ref = 'NSE4') # Para entregárselo, de nuevo le indicamos la etiqueta de nivel.\nnse_f_rec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1  \n[11] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3\n[21] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE4   NSE4   NSE4   NSE4  \n[31] NSE4  \nLevels: NSE4 NSE1 NSE2_3\n```\n:::\n:::\n\n\nEn realidad podríamos haberlo conseguido con la propia función factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(nse_f_rec,levels=c('NSE1','NSE2_3','NSE4')) # no lo asignamos al objeto para poder seguir utilizándolo posteriormente.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1   NSE1  \n[11] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3\n[21] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE4   NSE4   NSE4   NSE4  \n[31] NSE4  \nLevels: NSE1 NSE2_3 NSE4\n```\n:::\n:::\n\n\nEs importante introducir bien las etiquetas porque de lo contario asignara NA (missing).\nUn ejemplo introduciendo un error en la primera etiqueta.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(nse_f_rec,levels=c('NSE','NSE2_3','NSE4')) # no lo asignamos al objeto para poder seguir utilizándolo posteriormente.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>   <NA>  \n[11] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3\n[21] NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE2_3 NSE4   NSE4   NSE4   NSE4  \n[31] NSE4  \nLevels: NSE NSE2_3 NSE4\n```\n:::\n:::\n\n\nPara facilitar la tarea hemos utilizado la función *factor* para \"contener\" una variable ordinal.\nEn realidad R tiene una función específica para este tipo de factores ordenados (función *ordered*, o también función factor con argumento 'ordered=T'), y algunas funciones son capaces de \"entender\" que se trata de una categórica ordinal y tratarla como tal.\n\nEn cualquier caso no es esencial y se puede hacer que la función lo entienda como ordinal utilizando otras opciones al construir el modelo.\n\nComo lo hemos mencionado, insertaré aquí un ejemplo de esta función.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nordered(nse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE1 < NSE2 < NSE3 < NSE4\n```\n:::\n\n```{.r .cell-code}\nnse_of<-factor(nse,ordered = T)\n```\n:::\n\n\nComo se observa, Levels indica la relación entre niveles, y podemos utilizarlos para darle la vuelta a la relación de los niveles del factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(nse,levels=c('NSE4','NSE3','NSE2','NSE1'),ordered = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE1 NSE2 NSE2 NSE2 NSE2 NSE3\n[16] NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE3 NSE4 NSE4 NSE4 NSE4\n[31] NSE4\nLevels: NSE4 < NSE3 < NSE2 < NSE1\n```\n:::\n:::\n\n\nTodo esto está realizado con funciones básicas de R, lo que llamamos *base R*.\nEn la realidad, se utiliza lo que se ha dado en llamar *modern R*, que automatiza y amplía las posibilidades de estas operaciones de gestión de datos.\n\nSin embargo, en mi experiencia, no entender cómo *piensa* R (indexación de vectores, matrices y dataframes, utilización de factores, tipos de vector...), hace más difícil resolver los problemas que surjan al utilizar enfoques más eficientes (*modern R*), pero más complejos.\n\nAlgo semejante pasará con los gráficos.\nR base construye buenos gráficos, y aunque permiten mucha personalización, hacerlo conlleva mucho código.\nEl paquete *ggplot2* facilita mucho la tarea de construcción de gráficos una vez se entiende *'the Grammar of Graphics'* pero, para aprovechar su potencial al máximo, es útil entender como crear gráficos sencillos en R base, aunque debo reconocer que no todos los que nos dedicamos a la enseñanza estamos de acuerdo en esta cuestión.\n\n## Guardar los datos para la siguiente sesión.\n\nUna vez hemos trabajado los datos en R, no tendría mucho sentido volver a exportarlos con las nuevas variables creadas, salvo que deseemos enviárselo a alguien que no utilice R o no pueda importar su formato de datos.\n\nPodríamos guardar toda la imagen del espacio de trabajo (Workspace) y cargarla antes de trabajar con el nuevo dataframe en la siguiente sesión.\n\nSin embargo, y aunque cueste entenderlo al principio, es preferible guadar la menor cantida de objetos posibles y tratar de que sea el código el que lo construya cada vez.\nSi el objeto es muy grande o lleva mucho tiempo volver a generarlo con código, puede estar justificado guardar el o los objetos concretos.\n\nEn el caso del dataframe tenemos una estructura de datos que le sirve a R para gestionar esta parte.\nSon los archivos .RDS.\n\nEn este vínculo explican las dos opciones, pero de momento prefiero utilizar un archivo .RDS.\nSolo necesita un par de argumentos, el nombre del objeto dataframe que queremos guardar y el nombre del archivo en el que queremos guardarlo.\n\nEl dataframe que nos interesa es iam, porque contiene las nuevas variables y las transformaciones que hemos realizado.\nIncluyo los nombres de los argumentos, pero dado que son los dos primeros en realidad no haría falta[^1].\n\n[^1]: Recordad lo que comenté en la sesión anterior sobre las *posiciones relevantes* al llamar a las funciones\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(object=iam,file='iam.RDS')\n```\n:::\n\n\nEs importante que lo salvéis, porque lo cargaremos en la siguiente sesión.\nAsí no tendremos que volver a generar todas las funciones de nuevo.\n\n\n\n",
    "supporting": [
      "PR_3_lect_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}